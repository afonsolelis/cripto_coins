exit
c
Coin.where(name: coin[:coin]).first.last_price
Coin.where(name: coin[:coin]).first.name
Coin.where(name: coin[:coin]).first
Coin.find(coin[:coin])
coin
c
coins == response.parsed_body["all_coins"].map { |coin| coin["name"] }
coins
response.parsed_body["all_coins"].map { |coin| coin["name"] }
response.parsed_body["all_coins"].map { |coin| coin["name"]
response.parsed_body["all_coins"]
response.parsed_body
response.body["all_coins"]
response.body["all_coins"].name
c
CoinHistory.delete_all
Coin.delete_all
exit
Coin.first.name
service.call[:best_coin].first
CoinHistory.where(coin_id: Coin.first.id).last
CoinHistory.where(coin_id: Coin.first.id).last.update(price: "100000000")
CoinHistory.where(coin_id: Coin.first.id).last
CoinHistory.where(coin_id: Coin.first.id)
Coin.first.id
CoinHistory.where(coin_id: 1)
Coin.first.coin_prices
Coin.first.coin_histories
service.call[:best_coin].first
exit
Coin.all.count
CoinHistory.all.count
exit
service.call[:history].count
service.call[:best_coin].count
service.call
expected_response
expected_response[:best_coin]
expected_response[:best_coin].count
exit
best_coin
exit
service.call
exit
service.call
exit
response.parsed_body["best_coin"].count
response.parsed_body.count
c
exit
response.parsed_body
exit
coins(:btc)
coins
exit
Coin.new
response
exit
CoinHistory.new
exit
c
[0].reverse
0.reverse
(n * xy - x * y) / (n * x_sqrt - x**2)
xy = (1..n).to_a.zip(prices).map { |x, y| x * y }.sum
x_sqrt = (1..n).to_a.map { |i| i**2 }.sum
y = prices.sum
x = (1..n).to_a.sum
n = prices.size
exit
CoinHistory.all
Coin.all
c
best_coin
exit
Coin.create!(name: coin_name, last_price: last_price_consulted) if db_coin.nil?
last_price_consulted = coin_last_price_consulted(coin_name)
last_price_consulted
Coin.create!(name: coin_name, last_price: last_price_consulted) if db_coin.nil?
Coin.create!(name: coin_name, last_price_consulted: last_price_consulted) if db_coin.nil?
db_coin.nil?
db_coin
exit
Coin.where(name: coin_name)
coin_name
db_coin = Coin.where(name: coin_name).first
db_coin
coin_name
next
last_price_consulted = coin_last_price_consulted(coin_name)
exit
Coin.where(name: 'BTC')
a
exit
c
coin
exit
coin[:angular_coeficient]
coin
exit
c
prices.map { |data| data[:price].to_f }
prices.map { |data| data[:price] }
prices
exit
rxit
coin.name
coin
exit
Coin.find_or_create_by!(name: 'BTC') { |coin| coin.last_price = '0.0' }
Coin.find_or_create_by!(name: 'BTC') { |coin| coin.last_price: '0.0' }
Coin.find_or_create_by!(name: 'BTC') { last_price: '0.0' }
Coin.find_or_create_by!(name: 'BTC')
Coin.find_or_create_by!
c
CoinHistory.create
coin_tickes(coin)
coin
exit
HTTParty.get('https://www.mercadobitcoin.net/api/coins')
