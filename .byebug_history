exit
c
[0].reverse
0.reverse
(n * xy - x * y) / (n * x_sqrt - x**2)
xy = (1..n).to_a.zip(prices).map { |x, y| x * y }.sum
x_sqrt = (1..n).to_a.map { |i| i**2 }.sum
y = prices.sum
x = (1..n).to_a.sum
n = prices.size
exit
CoinHistory.all
Coin.all
c
best_coin
exit
Coin.create!(name: coin_name, last_price: last_price_consulted) if db_coin.nil?
last_price_consulted = coin_last_price_consulted(coin_name)
last_price_consulted
Coin.create!(name: coin_name, last_price: last_price_consulted) if db_coin.nil?
Coin.create!(name: coin_name, last_price_consulted: last_price_consulted) if db_coin.nil?
db_coin.nil?
db_coin
exit
Coin.where(name: coin_name)
coin_name
db_coin = Coin.where(name: coin_name).first
db_coin
coin_name
next
last_price_consulted = coin_last_price_consulted(coin_name)
exit
Coin.where(name: 'BTC')
a
exit
c
coin
exit
coin[:angular_coeficient]
coin
exit
c
prices.map { |data| data[:price].to_f }
prices.map { |data| data[:price] }
prices
exit
rxit
coin.name
coin
exit
Coin.find_or_create_by!(name: 'BTC') { |coin| coin.last_price = '0.0' }
Coin.find_or_create_by!(name: 'BTC') { |coin| coin.last_price: '0.0' }
Coin.find_or_create_by!(name: 'BTC') { last_price: '0.0' }
Coin.find_or_create_by!(name: 'BTC')
Coin.find_or_create_by!
c
CoinHistory.create
coin_tickes(coin)
coin
exit
HTTParty.get('https://www.mercadobitcoin.net/api/coins')
